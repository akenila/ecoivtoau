def clean_filename_for_result(original_filename):
    """
    Tạo tên file kết quả dựa trên tên gốc
    - Giữ lại chữ và số
    - Viết thường
    - Thêm tiền tố "result_"
    
    Args:
        original_filename: Tên file gốc
        
    Returns:
        Tên file kết quả
    """
    # Xử lý tên file
    base_name = os.path.basename(original_filename)
    name_without_ext, ext = os.path.splitext(base_name)
    
    # Giữ lại chữ và số, viết thường
    cleaned_name = re.sub(r'[^a-zA-Z0-9]', '', name_without_ext).lower()
    
    # Tạo tên file mới
    result_filename = f"{cleaned_name}"
    
    print(f"Tên file gốc: {original_filename}")
    print(f"Tên file kết quả: {result_filename}")
    
    return result_filename


def find_matching_srt(video_filename, srt_directory):
    """
    Tìm file SRT có tên bắt đầu chính xác bằng tên video (bao gồm cả đuôi .mp4)
    và ký tự tiếp theo (nếu có) phải là khoảng trắng, dấu chấm, gạch dưới, hoặc tương tự.
    """
    for fname in os.listdir(srt_directory):
        if fname.endswith('.srt') and fname.startswith(video_filename):
            # Kiểm tra ký tự tiếp theo (nếu có)
            next_char_index = len(video_filename)
            if len(fname) == next_char_index + 4:  # chỉ đúng .srt, không có hậu tố
                return os.path.join(srt_directory, fname)
            elif len(fname) > next_char_index + 4:
                next_char = fname[next_char_index]
                if next_char in [' ', '.', '_', '-']:
                    return os.path.join(srt_directory, fname)
    return None
# Function to find and click any element with text containing the specified text
def find_and_click_element_with_text(window, text_to_find):
    # Print all controls to help with debugging
    print("Listing all controls in the application:")
    window.print_control_identifiers()
    
    # Get all UI elements (not just buttons)
    all_elements = window.descendants()
    
    print(f"Looking for any element containing text: '{text_to_find}'")
    found = False
    
    # Check each element for the text
    for element in all_elements:
        try:
            element_text = element.window_text()
            control_type = element.control_type() if hasattr(element, 'control_type') else "Unknown"
            
            if element_text:  # Only print elements that have text
                print(f"Found element: '{element_text}' (Type: {control_type})")
            
            if text_to_find.lower() in element_text.lower():
                print(f"Found matching element: '{element_text}' (Type: {control_type})")
                
                # Try to click the element
                try:
                    element.click_input()  # Using click_input is sometimes more reliable
                    found = True
                    print(f"Successfully clicked the '{element_text}' element")
                    break
                except Exception as e:
                    print(f"Could not click element: {e}")
        except Exception as e:
            pass  # Skip elements that cause errors
    
    if not found:
        print(f"No element found containing text: '{text_to_find}'")

# Function to find an input field near specified text, click it and paste text
def find_click_and_paste_into_input(window, search_text, input_text):
    print(f"Looking for input field near text: '{search_text}'")
    
    # Print all controls to help with debugging
    window.print_control_identifiers()
    
    # Get all UI elements
    all_elements = window.descendants()
    
    # First find the element with the search text
    target_element = None
    for element in all_elements:
        try:
            element_text = element.window_text()
            if search_text.lower() in element_text.lower():
                print(f"Found element with text: '{element_text}'")
                target_element = element
                break
        except Exception:
            pass
    
    if not target_element:
        print(f"Could not find element with text: '{search_text}'")
        return False
    
    # Now look for input fields (Edit controls) near the found element
    input_fields = window.descendants(control_type="Edit")
    
    if input_fields:
        # Try the first input field found
        try:
            # First click on the input field to focus it
            print("Clicking on input field...")
            input_fields[0].click_input()
            
            # Wait a moment for the field to be focused
            time.sleep(0.5)
            
            # Put text in clipboard
            pyperclip.copy(input_text)
            
            # Clear existing text with Ctrl+A and Delete
            send_keys("^a{DELETE}")
            
            # Paste the text with Ctrl+V
            send_keys("^v")
            
            print(f"Clicked input field and pasted '{input_text}'")
            return True
        except Exception as e:
            print(f"Error interacting with input field: {e}")
    else:
        print("No input fields found")
    
    return False
def select_file_in_dialog(file_path, dialog_title="Open"):
    """
    Chọn file trong file dialog bằng cách nhập đường dẫn và nhấn Enter.
    """


    time.sleep(2)

    try:
        dialog = Desktop(backend="win32").window(title_re=f".*{dialog_title}.*")
        dialog.wait('visible', timeout=15)
        print(f"Đã tìm thấy dialog: {dialog.window_text()}")

        # Tìm ô nhập đường dẫn file
        edit = dialog.child_window(class_name="Edit")
        edit.set_edit_text(file_path)
        print(f"Đã nhập đường dẫn: {file_path}")

        # Gửi phím Enter để xác nhận chọn file
        send_keys('{ENTER}')
        print("Đã gửi phím Enter")
        return True
    except Exception as e:
        print(f"Lỗi khi chọn file trong dialog: {e}")
        return False

def enter_text_for_video_path(window, input_text):
    dismiss_update_dialog(app)


    print("Tìm label 'Đường dẫn video' và nút 'Chọn' cùng hàng...")

    try:
        # Tìm label
        label = window.child_window(title="Đường dẫn video", control_type="Text")
        label_rect = label.rectangle()

        # Tìm tất cả button
        buttons = window.descendants(control_type="Button")
        for btn in buttons:
            btn_text = btn.window_text().lower()
            btn_rect = btn.rectangle()
            # Kiểm tra nút nằm cùng hàng (chênh lệch top nhỏ) và bên phải label
            if ("chọn" in btn_text or "browse" in btn_text or "..." in btn_text) \
                and abs(btn_rect.top - label_rect.top) < 20 \
                and btn_rect.left > label_rect.right:
                print(f"Đã tìm thấy nút: '{btn.window_text()}'")
                btn.click_input()
                time.sleep(1)  # Đợi file dialog hiện lên

                # Gọi hàm chọn file trong dialog
                if select_file_in_dialog(input_text, dialog_title="Open") or select_file_in_dialog(input_text, dialog_title="Mở"):
                    print("Đã chọn file thành công qua file dialog")
                    return True
                else:
                    print("Không chọn được file qua file dialog")
                    return False

        print("Không tìm thấy nút 'Chọn' cùng hàng với label 'Đường dẫn video'")
        return False
    except Exception as e:
        print(f"Lỗi khi thao tác với nút 'Chọn': {e}")
        return False
def enter_text_for_srt_path(window, srt_path):
    dismiss_update_dialog(app)
    """
    Click vào nút 'Chọn' ở cùng hàng với label SRT, sau đó chọn file SRT qua file dialog.
    """

    print("Tìm label 'SRT' và nút 'Chọn' cùng hàng...")

    try:
        # Tìm label SRT
        label = window.child_window(title_re=".*SRT.*", control_type="Text")
        label_rect = label.rectangle()

        # Tìm tất cả button
        buttons = window.descendants(control_type="Button")
        for btn in buttons:
            btn_text = btn.window_text().lower()
            btn_rect = btn.rectangle()
            if ("chọn" in btn_text or "browse" in btn_text or "..." in btn_text) \
                and abs(btn_rect.top - label_rect.top) < 20 \
                and btn_rect.left > label_rect.right:
                print(f"Đã tìm thấy nút: '{btn.window_text()}'")
                btn.click_input()
                time.sleep(2)  # Đợi file dialog hiện lên

                # Gọi hàm chọn file trong dialog
                if select_file_in_dialog(srt_path, dialog_title="Open") or select_file_in_dialog(srt_path, dialog_title="Mở"):
                    print("Đã chọn file SRT thành công qua file dialog")
                    return True
                else:
                    print("Không chọn được file SRT qua file dialog")
                    return False

        print("Không tìm thấy nút 'Chọn' cùng hàng với label SRT")
        return False
    except Exception as e:
        print(f"Lỗi khi thao tác với nút 'Chọn' SRT: {e}")
        return False
def select_voice_from_combobox(window, voice_option):
    print(f"Looking for the combobox associated with 'Giọng đọc' to select '{voice_option}'")
    
    # Print all controls to help with debugging
    window.print_control_identifiers()
    
    try:
        # First find the label element
        label = window.child_window(title="Giọng đọc", control_type="Text")
        print("Found the 'Giọng đọc' label")
        
        # Get label's rectangle
        label_rect = label.rectangle()
        
        # Find all combo box controls in the window
        combo_boxes = window.descendants(control_type="ComboBox")
        
        # Look for combo box controls that are positioned near the label
        for combo in combo_boxes:
            combo_rect = combo.rectangle()
            
            # Check if combo box is to the right or below the label
            if (combo_rect.left >= label_rect.left and 
                abs(combo_rect.top - label_rect.top) < 50):  # within 50 pixels vertically
                
                print(f"Found combobox near 'Giọng đọc' label")
                
                # Click the combo box to open the dropdown
                combo.click_input()
                time.sleep(1)  # Wait for dropdown to appear
                
                # Now try to find and click the specified option
                try:
                    # Find all list items in the dropdown
                    dropdown_items = window.descendants(control_type="ListItem")
                    
                    for item in dropdown_items:
                        try:
                            item_text = item.window_text()
                            print(f"Dropdown option: '{item_text}'")
                            if voice_option.lower() in item_text.lower():
                                print(f"Found matching option '{item_text}' in dropdown")
                                item.click_input()
                                print(f"Selected '{item_text}' from the combobox")
                                return True
                        except Exception as e:
                            pass
                    
                    print(f"Could not find option '{voice_option}' in the dropdown")
                    # Click somewhere else to close the dropdown without making a selection
                    label.click_input()
                except Exception as e:
                    print(f"Error while trying to select from dropdown: {e}")
                
                return False
        
        print("Could not find a combobox near the 'Giọng đọc' label")
    except Exception as e:
        print(f"Error while looking for voice combobox: {e}")
    
    return False

def print_all_voice_combobox_options(window):
    print("Printing all options in the combobox associated with 'Giọng đọc'")
    
    try:
        # First find the label element
        label = window.child_window(title="Giọng đọc", control_type="Text")
        print("Found the 'Giọng đọc' label")
        
        # Get label's rectangle
        label_rect = label.rectangle()
        
        # Find all combo box controls in the window
        combo_boxes = window.descendants(control_type="ComboBox")
        
        # Look for combo box controls that are positioned near the label
        for combo in combo_boxes:
            combo_rect = combo.rectangle()
            
            # Check if combo box is to the right or below the label
            if (combo_rect.left >= label_rect.left and 
                abs(combo_rect.top - label_rect.top) < 50):  # within 50 pixels vertically
                
                print(f"Found combobox near 'Giọng đọc' label")
                
                # Click the combo box to open the dropdown
                combo.click_input()
                time.sleep(1)  # Wait for dropdown to appear
                
                # Get and print all options in the dropdown using control identifiers
                try:
                    print("\n=== AVAILABLE VOICE OPTIONS (Using Control Identifiers) ===")
                    
                    # Print control identifiers which might show all combobox items
                    print("Printing all controls including combobox items:")
                    window.print_control_identifiers()
                    
                    # Try to get combobox children directly (might work for some comboboxes)
                    print("\nAttempting to list combobox items directly:")
                    try:
                        # Some comboboxes expose their items as children
                        combo_items = combo.children()
                        if combo_items:
                            for item in combo_items:
                                try:
                                    item_text = item.window_text()
                                    if item_text:
                                        print(f"- Direct Child: {item_text}")
                                except Exception:
                                    pass
                        else:
                            print("No direct children found in combobox")
                            
                        # If dropdown isn't already open, try opening it
                        combo.click_input()
                        time.sleep(1)  # Wait for dropdown to appear
                    
                        # Find all list items in the dropdown
                        dropdown_items = window.descendants(control_type="ListItem")
                        
                        for item in dropdown_items:
                            try:
                                item_text = item.window_text()
                                print(f"- {item_text}")
                            except Exception as e:
                                print(f"Error getting text from option: {e}")
                    except Exception as e:
                        print(f"Error trying to access combobox items directly: {e}")
                        
                    print("=================================================\n")
                    
                    # Click somewhere else to close the dropdown if it was opened
                    label.click_input()
                    return True
                except Exception as e:
                    print(f"Error while trying to list dropdown options: {e}")
                    # Try to close the dropdown
                    label.click_input()
                
                return False
        
        print("Could not find a combobox near the 'Giọng đọc' label")
    except Exception as e:
        print(f"Error while looking for voice combobox: {e}")
    
    return False

def extract_combobox_values_from_identifiers(window):
    """Extract ComboBox values directly from the control identifiers output"""
    print("\n=== EXTRACTING VOICE OPTIONS FROM CONTROL IDENTIFIERS ===")
    

    # Redirect stdout to capture the print_control_identifiers output
    f = io.StringIO()
    with redirect_stdout(f):
        window.print_control_identifiers()
    
    # Get the output as a string
    output = f.getvalue()
    
    # Look for ComboBox entries that contain voice information

    
    # Pattern to match ComboBox entries with voice data
    # Example: 'ComboBox354 | ms-MY-Standard-B | AutoVoice1 | Malaysia | Nam | Free'
    pattern = r"ComboBox\d+\s+\|\s+([\w\-]+)\s+\|\s+AutoVoice\d+\s+\|\s+(.*?)\s+\|\s+(Nam|Nữ)\s+\|\s+(Free|Paid)"
    
    matches = re.findall(pattern, output)
    
    if matches:
        print("\nFound the following voice options:")
        print("-" * 80)
        print(f"{'Voice ID':<20} | {'Language/Region':<30} | {'Gender':<10} | {'Type':<10}")
        print("-" * 80)
        
        for match in matches:
            voice_id = match[0]
            language = match[1]
            gender = match[2]
            voice_type = match[3]
            print(f"{voice_id:<20} | {language:<30} | {gender:<10} | {voice_type:<10}")
        
        print("-" * 80)
        return True
    else:
        print("Could not find voice options in the control identifiers output")
        
        # Alternative approach: try using a simpler pattern
        simple_pattern = r"ComboBox\d+\s+\|(.*?)\|"
        simple_matches = re.findall(simple_pattern, output)
        
        if simple_matches:
            print("\nFound the following raw ComboBox entries:")
            for entry in simple_matches:
                print(f"- {entry.strip()}")
        
        return False

# # Find and click the "Thêm API" element first
# find_and_click_element_with_text(main_window, "Thêm API")

# Select a voice containing a specific number (e.g., 354 from your example)
 # Replace with the number you want to find in the voice name
def select_voice_by_number(window, number):
    dismiss_update_dialog(app)
    """
    Select a voice from the combobox by finding an option containing the specified number.
    
    Args:
        window: The window containing the combobox
        number: A number to look for in the voice name
    """
    print(f"Selecting voice containing number '{number}' in its name")
    
    try:
        # Find the combobox by its auto_id
        combo = window.child_window(auto_id="comboBox1", control_type="ComboBox")
        
        # Get all available items
        items = combo.texts()
        
        # Find an item containing the specified number
        target_item = None
        for item in items:
            if str(number) in item:
                target_item = item
                print(f"Found matching voice: {item}")
                break
        
        if not target_item:
            print(f"No voice found containing number '{number}'")
            return False
        
        # Click the combobox to focus it
        combo.click_input()
        time.sleep(0.5)
        
        # Clear the current text with Ctrl+A and Delete
        send_keys("^a{DELETE}")
        time.sleep(0.5)
        
        # Copy the target text to clipboard and paste it
        pyperclip.copy(target_item)
        send_keys("^v")
        time.sleep(0.5)
        
        # Press Enter to confirm selection
        send_keys("{ENTER}")
        
        print(f"Successfully selected voice: {target_item}")
        return True
        
    except Exception as e:
        print(f"Error selecting voice by number: {e}")
        return False

# Example usage:

def toggle_hide_old_subtitles(window, check=True):
    dismiss_update_dialog(app)
    print(f"Looking for 'Che sub cũ' checkbox to {'check' if check else 'uncheck'} it")
    
    try:
        # Try to find the checkbox directly by text
        checkboxes = window.descendants(control_type="CheckBox")
        
        # First approach: Look for checkbox with this exact text
        for checkbox in checkboxes:
            try:
                text = checkbox.window_text()
                if "che sub cũ" in text.lower():
                    print(f"Found 'Che sub cũ' checkbox with text: '{text}'")
                    
                    # Check current state
                    current_state = checkbox.get_toggle_state()
                    print(f"Current state: {'Checked' if current_state == 1 else 'Unchecked'}")
                    
                    # Toggle if needed
                    if (check and current_state == 0) or (not check and current_state == 1):
                        checkbox.toggle()
                        print(f"Toggled 'Che sub cũ' checkbox to {'checked' if check else 'unchecked'}")
                    else:
                        print(f"'Che sub cũ' checkbox already in desired state")
                    time.sleep(1)  # Wait for the toggle to take effect                        
                    return True
            except Exception as e:
                print(f"Error checking a checkbox: {e}")
        
        # Second approach: Look for a label with this text and find a nearby checkbox
        print("Looking for 'Che sub cũ' label...")
        all_elements = window.descendants()
        for element in all_elements:
            try:
                text = element.window_text()
                if "che sub cũ" in text.lower():
                    print(f"Found element with text: '{text}'")
                    
                    # Get element rectangle
                    element_rect = element.rectangle()
                    
                    # Look for a checkbox nearby
                    for checkbox in checkboxes:
                        checkbox_rect = checkbox.rectangle()
                        
                        # Check if checkbox is near the element (to the left or right)
                        horizontal_distance = min(
                            abs(checkbox_rect.right - element_rect.left),
                            abs(element_rect.right - checkbox_rect.left)
                        )
                        vertical_distance = abs(checkbox_rect.top - element_rect.top)
                        
                        if horizontal_distance < 50 and vertical_distance < 20:
                            print("Found checkbox near 'Che sub cũ' label")
                            
                            # Check current state
                            current_state = checkbox.get_toggle_state()
                            print(f"Current state: {'Checked' if current_state == 1 else 'Unchecked'}")
                            
                            # Toggle if needed
                            if (check and current_state == 0) or (not check and current_state == 1):
                                checkbox.toggle()
                                print(f"Toggled checkbox to {'checked' if check else 'unchecked'}")
                            else:
                                print("Checkbox already in desired state")

                            return True
            except Exception:
                pass
        
        print("Không tìm thấy nút 'Chọn' cùng hàng với label 'Đường dẫn video'")
        return False
    except Exception as e:
        print(f"Lỗi khi thao tác với nút 'Chọn': {e}")
        return False
def enter_value_and_click_delete(window, value="10000"):
    dismiss_update_dialog(app)
    """
    Find an input field with a delete button to its right,
    enter a value, and click the delete button.
    
    Args:
        window: The window containing the elements
        value: The value to enter in the field (default: 10000)
    
    Returns:
        True if successful, False otherwise
    """
    print(f"Looking for input field with nearby delete button to enter '{value}'")
    
    try:
        # Find all edit controls
        edit_controls = window.descendants(control_type="Edit")
        
        # Find all buttons that might be delete buttons
        delete_buttons = []
        all_elements = window.descendants()
        for element in all_elements:
            try:
                text = element.window_text()
                # Look for elements with text containing "xóa" (delete)
                if "xóa" in text.lower():
                    print(f"Found potential delete button: '{text}'")
                    delete_buttons.append(element)
            except Exception:
                pass
        
        if not delete_buttons:
            print("No delete buttons found")
            return False
        
        # For each edit control, check if there's a delete button to its right
        for edit in edit_controls:
            edit_rect = edit.rectangle()
            
            for button in delete_buttons:
                button_rect = button.rectangle()
                
                # Check if button is to the right of the edit field and vertically aligned
                if (button_rect.left > edit_rect.right and 
                    abs(button_rect.top - edit_rect.top) < 20):
                    
                    print(f"Found input field with delete button to its right")
                    
                    # Click the input field
                    edit.click_input()
                    time.sleep(0.5)
                    
                    # Clear existing text and enter new value
                    send_keys("^a{DELETE}")  # Ctrl+A, Delete
                    edit.type_keys(value)
                    print(f"Entered value '{value}' into the field")
                    
                    # Click the delete button
                    time.sleep(0.5)
                    button.click_input()
                    print(f"Clicked the delete button")
                    
                    # Wait for the success popup to appear
                    time.sleep(1)
                    
                    # Handle the success popup
                    try:
                        # Find popup dialog windows
                        popup_windows = app.windows(visible_only=True)
                        for popup in popup_windows:
                            try:
                                # Check if it's not the main window
                                if popup != window:
                                    popup_title = popup.window_text()
                                    print(f"Found popup: '{popup_title}'")
                                    
                                    # Find and click OK or close button
                                    # Try to find common button texts
                                    for button_text in ["OK", "Ok", "Đồng ý", "Đóng", "Tắt"]:
                                        try:
                                            buttons = popup.descendants(title=button_text, control_type="Button")
                                            if buttons:
                                                ok_button = buttons[0]
                                                print(f"Found '{button_text}' button in popup")
                                                ok_button.click_input()
                                                print("Clicked button to close popup")
                                                time.sleep(0.5)
                                                return True
                                        except Exception as button_error:
                                            print(f"Error finding '{button_text}' button: {button_error}")
                                    
                                    # If no specific button found, try to press Enter to close
                                    print("No specific button found, trying Enter key")
                                    popup.set_focus()
                                    send_keys("{ENTER}")
                                    time.sleep(0.5)
                                    
                                    return True
                            except Exception as popup_error:
                                print(f"Error processing popup window: {popup_error}")
                        
                        print("No popup found, operation may have completed without dialog")
                    except Exception as e:
                        print(f"Error handling popup: {e}")
                    
                    return True
    
    except Exception as e:
        print(f"Error entering value and clicking delete button: {e}")
        return False

# Example usage in main code:


def read_key_value_pairs(file_path):
    """
    Read key:value pairs from a text file.
    
    Args:
        file_path: Path to the text file containing key:value pairs
        
    Returns:
        Dictionary of key:value pairs
    """
    pairs = {}
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            for line in file:
                line = line.strip()
                if line and ':' in line:
                    key, value = line.split(':', 1)
                    pairs[key.strip()] = value.strip()
        print(f"Loaded {len(pairs)} key:value pairs from {file_path}")
    except Exception as e:
        print(f"Error reading key:value pairs from {file_path}: {e}")
    
    return pairs

def scan_directory_for_videos(directory):
    """
    Scan a directory for video files.
    """
    directory = directory.replace('/', '\\')
    video_extensions = ['.mp4', '.avi', '.mkv', '.mov', '.wmv']
    videos = []
    
    try:
        for root, _, files in os.walk(directory):
            for file in files:
                if any(file.lower().endswith(ext) for ext in video_extensions):
                    videos.append(os.path.join(root, file))
        
        print(f"Found {len(videos)} video files in {directory}")
    except Exception as e:
        print(f"Error scanning directory {directory}: {e}")
    
    return videos
def wait_until_output_video_stable(video_filename, stable_checks=3, check_interval=2, timeout=600):
    """
    Theo dõi file kết quả cho đến khi kích thước file không đổi trong stable_checks lần liên tiếp.
    Trả về True nếu file ổn định, False nếu hết timeout.
    """
    log(f"Waiting for output video to stabilize: {video_filename}")
    video_name = clean_filename_for_result(video_filename)
    output_path = os.path.join(
        ".", "AutoVoice", "AutoVoice", "video", video_name, f"result{video_name}.mp4"
    )
    stable_count = 0
    last_size = -1
    waited = 0

    while True:
        if not os.path.exists(output_path):
            stable_count = 0
            last_size = -1
            log(f"File không tồn tại: {output_path}")
        else:
            current_size = os.path.getsize(output_path)
            if current_size == last_size and current_size > 0:
                stable_count += 1
            else:
                stable_count = 0
            log(f"Current size of {output_path}: {current_size} bytes (Stable count: {stable_count})")
            last_size = current_size
            if stable_count >= stable_checks:
                print(f"File kết quả đã ổn định: {output_path}")
                return True
        dismiss_update_dialog(app)
        time.sleep(check_interval)
        waited += check_interval
    print(f"Hết thời gian chờ, file chưa ổn định: {output_path}")
    return False
def process_videos_with_keys(window, key_value_file, video_directory, srt_directory):
    video_directory = video_directory.replace('/', '\\')
    srt_directory = srt_directory.replace('/', '\\')
    print(f"Processing videos with keys from {key_value_file}")
    
    # Read key:value pairs
    pairs = read_key_value_pairs(key_value_file)
    if not pairs:
        print("No key:value pairs found, aborting")
        return
    
    # Scan for video files
    videos = scan_directory_for_videos(video_directory)
    if not videos:
        print("No videos found, aborting")
        return
    
    # Process each video
    for video_path in videos:
        dismiss_update_dialog(app)
        video_path = video_path.replace('/', '\\')
        video_filename = os.path.basename(video_path)
        video_name_without_ext = os.path.splitext(video_filename)[0]
        log(f"Processing video: {video_filename}")
        
        # Find corresponding SRT file
        video_filename = os.path.basename(video_path)
        srt_path = find_matching_srt(video_name_without_ext, srt_directory)
        
        if not srt_path or not os.path.exists(srt_path):
            log(f"SRT file not found for video: {video_filename}, skipping")
            continue
        
        # Check if any key is in the video filename
        matched_key = None
        matched_value = None
        
        for key, value in pairs.items():
            if key in video_filename:
                matched_key = key
                matched_value = value
                print(f"Matched key '{key}' with value '{value}'")
                break
        
        if not matched_key:
            print(f"No key match found for {video_filename}, skipping")
            continue
        
        # Enter the video path
        print(f"Entering video path: {video_path}")
        if not enter_text_for_video_path(window, video_path):
            print(f"Failed to enter video path, skipping this video")
            continue
        
        dismiss_update_dialog(app)
        # Enter the SRT path
        print(f"Entering SRT path: {srt_path}")
        if not enter_text_for_srt_path(window, srt_path):
            print(f"Failed to enter SRT path, skipping this video")
            continue
        
        dismiss_update_dialog(app)
        # Select voice based on the value (voice number)
        print(f"Selecting voice with number {matched_value}")
        if not select_voice_by_number(window, matched_value):
            print(f"Failed to select voice, skipping this video")
            continue
        
        dismiss_update_dialog(app)
        # Check the "Che sub cũ" checkbox
        log("Checking 'Che sub cũ' checkbox")
        toggle_hide_old_subtitles(window, check=True)
        dismiss_update_dialog(app)
        main_window = window
        if main_window is not None:
            try:
                # Tìm tất cả control type Dialog có title Thông báo
                for ctrl in main_window.descendants():
                    try:
                        if ctrl.friendly_class_name() == "Dialog" and ctrl.window_text() == "Thông báo":
                            dialog = ctrl
                            # Tìm các nút thường gặp
                            for btn_text in ["OK", "Đóng", "Close", "Xác nhận"]:
                                try:
                                    btn_spec = dialog.child_window(title=btn_text, control_type="Button")
                                    if btn_spec.exists():
                                        btn = btn_spec.wrapper_object()
                                        btn.click_input()
                                        print(f"Đã bấm nút {btn_text} để tắt popup Thông báo.")
                                except Exception:
                                    continue
                            # Nếu không có nút, thử đóng dialog
                            dialog.close()
                            print("Đã đóng dialog Thông báo.")
                    except Exception:
                        continue
            except Exception as e:
                log(f"Lỗi khi đóng popup Thông báo: {e}")
            
            print("No popup found, operation may have completed without dialog")
        dismiss_update_dialog(app)
        # === Bổ sung: tìm khung video và khoanh vùng subtitle ===
        log("Tìm khung video và khoanh vùng subtitle...")
        candidates = find_video_window(window)
        if candidates and len(candidates) >= 1:
            # Ưu tiên khung đầu tiên, hoặc bạn có thể chọn theo index khác nếu muốn
            try_drag_slider_and_find_subtitle(candidates[2], max_attempts=8, main_window=window)
        else:
            log("Không tìm thấy khung video để khoanh subtitle.")

        # Enter value and click delete button
        print("Entering value and clicking delete button")
        enter_value_and_click_delete(window, "10000")
        dismiss_update_dialog(app)
        
        # Wait between processing videos
        time.sleep(2)
        click_start_button(window)
        print("Clicking start button to process video")
        wait_until_output_video_stable(video_filename)
        close_completion_popup()
        print(f"Completed processing video: {video_filename}")
def find_video_window(window):
    """
    Tìm control con có khả năng là cửa sổ hiển thị video.
    """
    print("Liệt kê các control để xác định cửa sổ video:")
    window.print_control_identifiers()

    # Thử lọc theo control_type hoặc class_name phổ biến
    candidates = []
    for ctrl in window.descendants():
        # Bạn có thể thay đổi điều kiện dưới đây cho phù hợp app của bạn
        if ctrl.friendly_class_name() in ["Pane", "Custom", "Static", "WindowsFormsHost"]:
            # Có thể kiểm tra thêm về kích thước hoặc vị trí nếu cần
            rect = ctrl.rectangle()
            if rect.width() > 200 and rect.height() > 100:
                candidates.append(ctrl)
                print(f"Candidate: {ctrl.window_text()} | {ctrl.friendly_class_name()} | {rect}")

    if candidates:
        print(f"Đã tìm thấy {len(candidates)} control nghi là video.")
        return candidates
    else:
        print("Không tìm thấy control nào nghi là video.")
        return None

def highlight_control_with_mouse(control, duration=3):
    """
    Di chuyển chuột xung quanh viền control trong thời gian duration (giây).
    """
    rect = control.rectangle()
    print(f"Highlight control tại: {rect}")

    # Các điểm quanh viền
    points = [
        (rect.left + 5, rect.top + 5),
        (rect.right - 5, rect.top + 5),
        (rect.right - 5, rect.bottom - 5),
        (rect.left + 5, rect.bottom - 5),
        (rect.left + rect.width() // 2, rect.top + 5),
        (rect.right - 5, rect.top + rect.height() // 2),
        (rect.left + rect.width() // 2, rect.bottom - 5),
        (rect.left + 5, rect.top + rect.height() // 2),
    ]

    start_time = time.time()
    idx = 0
    while time.time() - start_time < duration:
        move(coords=points[idx % len(points)])
        idx += 1
        time.sleep(0.2)

    print("Đã highlight xong control.")
# Example usage:
def has_horizontal_scrollbar(control):
    """
    Kiểm tra control này hoặc control con của nó có thanh scroll ngang không.
    """
    # Kiểm tra trực tiếp control này
    if "ScrollBar" in control.friendly_class_name() or "ScrollBar" in control.class_name():
        # Kiểm tra chiều ngang
        if hasattr(control, "is_horizontal") and control.is_horizontal():
            return True

    # Kiểm tra các control con
    for child in control.descendants():
        if "ScrollBar" in child.friendly_class_name() or "ScrollBar" in child.class_name():
            # Một số control có thuộc tính orientation hoặc is_horizontal
            try:
                if hasattr(child, "is_horizontal") and child.is_horizontal():
                    return True
                # Nếu không có, kiểm tra kích thước: ngang dài hơn dọc
                rect = child.rectangle()
                if rect.width() > rect.height():
                    return True
            except Exception:
                continue
    return False

def drag_around_subtitle_in_video_frame(video_frame):
    # Tìm control con có text giống subtitle
    for child in video_frame.descendants():
        text = child.window_text()
        if text and len(text) > 3:  # Có thể thêm điều kiện nhận diện subtitle
            rect = child.rectangle()
            top_left = (rect.left + 2, rect.top + 2)
            bottom_right = (rect.right - 2, rect.bottom - 2)
            print(f"Kéo chuột quanh subtitle: {text} từ {top_left} đến {bottom_right}")

            move(coords=top_left)
            press(button='left', coords=top_left)
            time.sleep(0.2)
            move(coords=bottom_right)
            time.sleep(0.2)
            release(button='left', coords=bottom_right)
            print("Đã kéo chuột quanh subtitle.")
            return
    print("Không tìm thấy control subtitle.")
def print_all_text_controls(control):
    """
    In ra tất cả control con có text (subtitle hoặc label) trong control truyền vào.
    """
    for child in control.descendants():
        text = child.window_text()
        if text and text.strip():
            rect = child.rectangle()
            print(f"Text: '{text}' | Class: {child.friendly_class_name()} | Rect: {rect}")

def easyocr_and_drag_subtitle(rect):
    # Chụp ảnh vùng khung video
    img = ImageGrab.grab(bbox=(rect.left, rect.top, rect.right, rect.bottom))
    img_np = np.array(img)

    # Nhận diện text bằng EasyOCR
    languages = [lang1_var.get()]
    if lang2_var.get().strip():
        languages.append(lang2_var.get())
    
    reader = easyocr.Reader(languages)
    results = reader.readtext(img_np)

    found = False
    rect_height = rect.height()
    lower_half_top = rect_height // 2

    for (bbox, text, conf) in results:
        # Tính điểm giữa của bbox
        y_coords = [point[1] for point in bbox]
        y_center = int(sum(y_coords) / 4)
        # Chỉ lấy text nằm ở nửa dưới
        if y_center >= lower_half_top:
            if text.strip() and len(text.strip()) > 2:
                print(f"Subtitle OCR (nửa dưới): '{text}' | bbox: {bbox} | conf: {conf}")
                x_min = int(min([point[0] for point in bbox]))
                y_min = int(min([point[1] for point in bbox]))
                x_max = int(max([point[0] for point in bbox]))
                y_max = int(max([point[1] for point in bbox]))
                abs_left = rect.left + x_min
                abs_top = rect.top + y_min
                abs_right = rect.left + x_max
                abs_bottom = rect.top + y_max
                # Kéo chuột quanh vùng subtitle
                move(coords=(abs_left, abs_top))
                press(button='left', coords=(abs_left, abs_top))
                time.sleep(0.2)
                move(coords=(abs_right, abs_bottom))
                time.sleep(0.2)
                release(button='left', coords=(abs_right, abs_bottom))
                print("Đã kéo chuột quanh subtitle bằng EasyOCR.")
                found = True
                break
    if not found:
        print("Không tìm thấy subtitle ở nửa dưới bằng EasyOCR.")



def click_random_positions_on_slider(video_frame):
    # Tìm control slider trong video_frame
    slider = None
    for child in video_frame.descendants():
        if child.friendly_class_name() == "Slider":
            rect = child.rectangle()
            if rect.width() > rect.height():  # Chỉ lấy slider ngang
                slider = child
                break
    if not slider:
        print("Không tìm thấy slider ngang trong khung video.")
        return

    rect = slider.rectangle()
    print(f"Slider ngang rect: {rect}")

    # Chọn 2 vị trí ngẫu nhiên ở khoảng giữa (30% - 70%)
    width = rect.width()
    # Dịch lên 10 pixel so với giữa slider
    y = rect.top + rect.height() // 2 - 12
    x1 = rect.left + int(width * random.uniform(0.3, 0.7))
    x2 = rect.left + int(width * random.uniform(0.3, 0.7))

    print(f"Click vào slider ngang tại: ({x1}, {y}) và ({x2}, {y})")

    move(coords=(x1, y))
    click(button='left', coords=(x1, y))
    move(coords=(x2, y))
    click(button='left', coords=(x2, y))
def print_horizontal_sliders(video_frame):
    sliders = []
    for child in video_frame.descendants():
        if child.friendly_class_name() == "Slider":
            rect = child.rectangle()
            if rect.width() > rect.height():
                sliders.append((child, rect))
    print(f"Tổng số slider ngang: {len(sliders)}")
    for i, (slider, rect) in enumerate(sliders):
        print(f"Slider ngang #{i+1}: rect={rect}")

def drag_across_slider(video_frame, steps=50, delay=0.2):
    # Tìm control slider ngang trong video_frame
    slider = None
    for child in video_frame.descendants():
        if child.friendly_class_name() == "Slider":
            rect = child.rectangle()
            if rect.width() > rect.height():
                slider = child
                break
    if not slider:
        print("Không tìm thấy slider ngang trong khung video.")
        return

    rect = slider.rectangle()
    print(f"Slider ngang rect: {rect}")

    width = rect.width()
    # Dịch lên 12 pixel nếu cần (giống code cũ)
    y = rect.top + rect.height() // 2 - 12

    # Điểm 1: 1/4 đầu
    x1 = rect.left + int(width * 0.25)
    # Điểm 2: 1/4 cuối
    x2 = rect.left + int(width * 0.75)

    print(f"Kéo chuột từ ({x1}, {y}) đến ({x2}, {y}) trên slider ngang.")

    move(coords=(x1, y))
    press(button='left', coords=(x1, y))
    for i in range(1, steps + 1):
        x = int(x1 + (x2 - x1) * i / steps)
        move(coords=(x, y))
        time.sleep(delay)
    release(button='left', coords=(x2, y))
    print("Đã kéo chuột từ từ trên slider ngang.")
def is_probably_subtitle(text):
    # Loại bỏ text toàn số hoặc rất ngắn
    if text.isdigit() or len(text.strip()) < 4:
        return False
    # Loại bỏ text không có dấu cách (thường subtitle là câu)
    if " " not in text:
        return False
    # Loại bỏ text toàn in hoa (thường là watermark/logo)
    if text.isupper():
        return False
    # Có thể bổ sung thêm các điều kiện khác nếu cần
    return True

def improved_drag(start_x, start_y, end_x, end_y, duration=1.0, steps=50):
    """
    Thực hiện hành động kéo chuột từ (start_x, start_y) đến (end_x, end_y) 
    với nhiều bước trung gian hơn và thời gian chờ đủ.
    
    Args:
        start_x, start_y: Tọa độ điểm bắt đầu
        end_x, end_y: Tọa độ điểm kết thúc
        duration: Tổng thời gian kéo (giây)
        steps: Số bước trung gian
    """
    import time
    import numpy as np
    
    # Di chuyển đến vị trí bắt đầu và đảm bảo chuột đã ở đúng vị trí
    move(coords=(start_x, start_y))
    time.sleep(0.2)  # Chờ chuột đến đúng vị trí
    
    # Nhấn chuột trái
    press(button='left', coords=(start_x, start_y))
    time.sleep(0.2)  # Chờ sự kiện press được xử lý
    
    # Tạo đường cong tự nhiên hơn cho chuyển động chuột
    # Sử dụng hàm easing để làm cho chuyển động mượt hơn
    def ease_out_quad(t):
        return t * (2 - t)
    
    for i in range(1, steps + 1):
        t = i / steps
        # Áp dụng easing function để chuyển động tự nhiên hơn
        t_eased = ease_out_quad(t)
        
        current_x = int(start_x + (end_x - start_x) * t_eased)
        current_y = int(start_y + (end_y - start_y) * t_eased)
        
        move(coords=(current_x, current_y))
        # Phân bố thời gian chờ giữa các bước
        time.sleep(duration / steps)
    
    # Thêm delay trước khi thả chuột
    time.sleep(0.2)
    
    # Thả chuột
    release(button='left', coords=(end_x, end_y))
    time.sleep(0.3)  # Chờ để sự kiện được xử lý hoàn toàn
import numpy as np
from PIL import ImageGrab, Image, ImageDraw
from pywinauto.mouse import move, press, release
import time
import easyocr
import os
from datetime import datetime
def click_upper_half_of_video_frame(video_frame, main_window):
    try:
        # Lấy rectangle của khung video
        rect = video_frame
        
        # Tính toán nửa trên của khung video
        upper_half_top = rect.top
        upper_half_bottom = rect.top + rect.height() // 2
        
        # Chọn một điểm ngẫu nhiên trong nửa trên
        random_x = rect.left + random.randint(rect.width() // 4, rect.width() * 3 // 4)
        random_y = random.randint(upper_half_top + 10, upper_half_bottom - 10)
        
        print(f"Click vào điểm ngẫu nhiên nửa trên: ({random_x}, {random_y})")
        
        # Click vào điểm ngẫu nhiên
        move(coords=(random_x, random_y))
        click(button='left', coords=(random_x, random_y))
        
        # Đợi một chút để popup có thể xuất hiện
        time.sleep(0.8)
        
        # Xử lý popup nếu xuất hiện
        if main_window is not None:
            try:
                # Tìm tất cả control type Dialog có title Thông báo
                for ctrl in main_window.descendants():
                    try:
                        if ctrl.friendly_class_name() == "Dialog":
                            dialog = ctrl
                            # Tìm các nút thường gặp
                            for btn_text in ["OK", "Đóng", "Close", "Xác nhận"]:
                                try:
                                    btn_spec = dialog.child_window(title=btn_text, control_type="Button")
                                    if btn_spec.exists():
                                        btn = btn_spec.wrapper_object()
                                        btn.click_input()
                                        print(f"Đã bấm nút {btn_text} để tắt popup Thông báo.")
                                except Exception:
                                    continue
                            # Nếu không có nút, thử đóng dialog
                            dialog.close()
                            popup_found = True
                            print("Đã đóng dialog Thông báo.")
                    except Exception:
                        continue
            except Exception as e:
                log(f"Lỗi khi đóng popup Thông báo: {e}")
        
        return True
    except Exception as e:
        print(f"Lỗi khi click vào nửa trên của video: {str(e)}")
        return False
def easyocr_and_drag_subtitle_with_wider_box(video_frame, expand_width=40, save_debug_image=False, main_window=None):
    print("Tìm text gần trung tâm khung hình nhất...")
    
    # Lấy rectangle của khung video
    rect = video_frame
    
    # Chụp ảnh toàn bộ khung video
    img = ImageGrab.grab(bbox=(rect.left, rect.top, rect.right, rect.bottom))
    img_np = np.array(img)
    
    # Tính toán tọa độ trung tâm khung hình
    center_x = rect.width() // 2
    center_y = rect.height() // 2
    
    # Sử dụng EasyOCR để phát hiện tất cả text trong khung
    reader = easyocr.Reader([])  # Thêm nhiều ngôn ngữ để nhận diện đa dạng
    results = reader.readtext(img_np)
    
    if not results:
        print("Không phát hiện text nào trong khung video")
        return False
    
    # Tạo hình ảnh debug nếu được yêu cầu
    if save_debug_image:
        debug_img = img.copy()
        draw = ImageDraw.Draw(debug_img)
        # Vẽ điểm trung tâm
        draw.ellipse([(center_x-5, center_y-5), (center_x+5, center_y+5)], 
                     fill=(255, 0, 0), outline=(255, 0, 0))
    
    # Tìm text gần trung tâm nhất
    min_distance = float('inf')
    closest_text = None
    
    for (bbox, text, conf) in results:
        # Vẽ tất cả các khung text được phát hiện bằng màu xanh nước biển
        if save_debug_image:
            points = [(int(p[0]), int(p[1])) for p in bbox]
            draw.polygon(points, outline=(0, 0, 255), width=2)
            # Thêm nhãn text với độ tin cậy
            label_position = (int(bbox[0][0]), int(bbox[0][1]) - 15)
            draw.text(label_position, f"{text} ({conf:.2f})", fill=(0, 0, 255))
        
        # Tính tọa độ trung tâm của text
        text_center_x = sum(point[0] for point in bbox) / 4
        text_center_y = sum(point[1] for point in bbox) / 4
        
        # Tính khoảng cách Euclidean từ trung tâm text đến trung tâm khung hình
        distance = np.sqrt((text_center_x - center_x)**2 + (text_center_y - center_y)**2)
        
        print(f"Text: '{text}' | Khoảng cách đến trung tâm: {distance:.1f}px | Confidence: {conf:.2f}")
        
        # Lưu text gần nhất
        if distance < min_distance:
            min_distance = distance
            closest_text = (bbox, text, conf)
    
    if not closest_text:
        print("Không tìm được text gần trung tâm")
        return False
        
    # Text được chọn
    bbox, text, conf = closest_text
    print(f"Text gần trung tâm nhất: '{text}' | Khoảng cách: {min_distance:.1f}px")
    
    # Tính toán hộp giới hạn với mở rộng theo chiều ngang
    x_min = int(min([point[0] for point in bbox]))
    y_min = int(min([point[1] for point in bbox]))
    x_max = int(max([point[0] for point in bbox]))
    y_max = int(max([point[1] for point in bbox]))
    
    # Áp dụng mở rộng theo chiều ngang
    local_left = max(x_min - expand_width, 0)
    local_top = y_min
    local_right = min(x_max + expand_width, rect.width())
    local_bottom = y_max
    
    # Tính tọa độ màn hình tuyệt đối
    abs_left = rect.left + local_left
    abs_top = rect.top + local_top
    abs_right = rect.left + local_right
    abs_bottom = rect.top + local_bottom
    
    # Vẽ hộp text được chọn bằng màu xanh lá cây trên hình ảnh debug
    if save_debug_image:
        # Vẽ hộp gốc bằng màu xanh lá cây
        points = [(int(p[0]), int(p[1])) for p in bbox]
        draw.polygon(points, outline=(0, 255, 0), width=3)
        
        # Vẽ hộp mở rộng bằng màu đỏ
        draw.rectangle([local_left, local_top, local_right, local_bottom], 
                     outline=(255, 0, 0), width=2)
        
        # Vẽ đường từ trung tâm khung đến trung tâm text
        text_center_x = sum(point[0] for point in bbox) / 4
        text_center_y = sum(point[1] for point in bbox) / 4
        draw.line([(center_x, center_y), (text_center_x, text_center_y)], 
                 fill=(255, 255, 0), width=2)
        
        # Lưu hình ảnh debug
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        debug_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "debug_images")
        os.makedirs(debug_dir, exist_ok=True)
        debug_path = os.path.join(debug_dir, f"subtitle_debug_{timestamp}.png")
        debug_img.save(debug_path)
        print(f"Đã lưu hình ảnh debug tại: {debug_path}")
    
    # Vẽ hộp chọn bằng cách kéo chuột
    print(f"Vẽ hộp chọn từ ({abs_left}, {abs_top}) đến ({abs_right}, {abs_bottom})")
    move(coords=(abs_left, abs_top))
    press(button='left', coords=(abs_left, abs_top))
    time.sleep(0.2)
    move(coords=(abs_right, abs_bottom))
    time.sleep(0.2)
    release(button='left', coords=(abs_right, abs_bottom))
    popup_found = False
    if main_window is not None:
        try:
            # Tìm tất cả control type Dialog có title Thông báo
            for ctrl in main_window.descendants():
                try:
                    if ctrl.friendly_class_name() == "Dialog":
                        dialog = ctrl
                        # Tìm các nút thường gặp
                        for btn_text in ["OK", "Đóng", "Close", "Xác nhận"]:
                            try:
                                btn_spec = dialog.child_window(title=btn_text, control_type="Button")
                                if btn_spec.exists():
                                    btn = btn_spec.wrapper_object()
                                    btn.click_input()
                                    print(f"Đã bấm nút {btn_text} để tắt popup Thông báo.")
                            except Exception:
                                continue
                        # Nếu không có nút, thử đóng dialog
                        dialog.close()
                        popup_found = True
                        print("Đã đóng dialog Thông báo.")
                except Exception:
                    continue
        except Exception as e:
            log(f"Lỗi khi đóng popup Thông báo: {e}")

    if popup_found and expand_width != 20:
        click_upper_half_of_video_frame(video_frame, main_window)
        log("Thử lại với width_expand giảm 20")
        return easyocr_and_drag_subtitle_with_wider_box(rect, expand_width=expand_width-20, main_window=main_window)
    log("Đã khoanh vùng subtitle nhiều dòng.")

    print("Đã chọn text thành công")
    return True

def try_drag_slider_and_find_subtitle(video_frame, max_attempts=8, main_window=None):
    """
    Kéo slider ngang với các vị trí khác nhau, sau đó nhận diện subtitle.
    Nếu tìm thấy subtitle thì khoanh vùng, nếu không thì thử lại với vị trí khác.
    """
    slider = None
    for child in video_frame.descendants():
        # Nếu là WindowSpecification thì chuyển sang wrapper_object
        if hasattr(child, 'friendly_class_name') and child.friendly_class_name() == "Slider":
            # Nếu là WindowSpecification, chuyển sang UIAWrapper
            if hasattr(child, 'wrapper_object'):
                child = child.wrapper_object()
            rect = child.rectangle()
            if rect.width() > rect.height():
                slider = child
                break
    if not slider:
        print("Không tìm thấy slider ngang trong khung video.")
        return
    log(f"Slider ngang rect: {slider.rectangle()}")

    rect = slider.rectangle()
    width = rect.width()
    y = rect.top + rect.height() // 2 - 12
    log(f"Vị trí kéo slider: ({rect.left}, {y}) đến ({rect.right}, {y})")
    for attempt in range(max_attempts):
        # Sinh 2 điểm khác nhau ở vùng 20%–80%
        x1 = rect.left + int(width * np.random.uniform(0.2, 0.4))
        x2 = rect.left + int(width * np.random.uniform(0.6, 0.8))
        log(f"[Lần {attempt+1}] Kéo slider từ ({x1}, {y}) đến ({x2}, {y})")
        move(coords=(x1, y))
        press(button='left', coords=(x1, y))
        for i in range(1, 30):
            x = int(x1 + (x2 - x1) * i / 30)
            move(coords=(x, y))
            time.sleep(0.01)
        release(button='left', coords=(x2, y))
        time.sleep(0.5)  # Đợi video/subtitle cập nhật

        # Lấy rect khung video (giả sử là video_frame.rect)
        video_rect = video_frame.rectangle()
        found = easyocr_and_drag_subtitle_with_wider_box(video_rect, expand_width=60, main_window=main_window)
        if found:
            log("Đã tìm thấy subtitle, dừng thử lại slider.")
            return
        else:
            print("Không tìm thấy subtitle, thử lại slider với vị trí khác.")
    print("Đã thử hết số lần mà không tìm thấy subtitle.")

# Thêm hàm log mặc định
def log(msg):
    print(msg)

# Thay tất cả các print(...) thành log(...) nếu muốn log ra GUI
# (Bạn có thể thay thế toàn bộ print(...) => log(...) nếu muốn đồng bộ log ra GUI)
def close_update_popup(timeout=10):
    """
    Tìm và tắt popup update nếu xuất hiện.
    """
    
    print("Đang kiểm tra popup update...")
    start_time = time.time()
    while time.time() - start_time < timeout:
        try:
            # Lấy tất cả cửa sổ đang mở
            windows = Desktop(backend="uia").windows()
            for win in windows:
                title = win.window_text()
                if "update" in title.lower():
                    print(f"Phát hiện popup update: '{title}'")
                    # Tìm các nút phổ biến để đóng
                    for btn_text in ["Đóng", "Tắt", "Cancel", "Hủy", "Close"]:
                        try:
                            btn = win.child_window(title_re=f".*{btn_text}.*", control_type="Button")
                            if btn.exists():
                                btn.click_input()
                                print(f"Đã click nút '{btn_text}' để tắt popup update.")
                                return True
                        except Exception:
                            continue
                    # Nếu không tìm thấy nút, thử nhấn Esc
                    try:
                        win.set_focus()
                        send_keys("{ESC}")
                        print("Đã gửi phím ESC để tắt popup update.")
                        return True
                    except Exception:
                        pass
            time.sleep(1)
        except Exception as e:
            print(f"Lỗi khi kiểm tra popup update: {e}")
            time.sleep(1)
    print("Không phát hiện popup update hoặc không thể tắt.")
    return False

from pywinauto import Desktop
import time

def close_completion_popup():
    """
    Tìm và đóng popup "xong" không tiêu đề
    
    Returns:
        True nếu đóng thành công, False nếu không tìm thấy
    """
    try:
        print("Đang tìm popup 'xong'...")
        
        # Đợi popup xuất hiện (có thể điều chỉnh thời gian chờ nếu cần)
        time.sleep(1.5)
        
        # Tìm tất cả các cửa sổ
        windows = Desktop(backend="uia").windows()
        
        # Tìm cửa sổ popup có chứa text "xong" và nút OK
        for window in windows:
            try:
                # Tìm tất cả các control có text trong cửa sổ này
                text_elements = window.descendants(control_type="Text") + window.descendants(control_type="Static")
                
                # Kiểm tra xem có phần tử nào chứa chữ "xong" không
                has_xong_text = False
                for text_elem in text_elements:
                    try:
                        text = text_elem.window_text() if hasattr(text_elem, 'window_text') else ""
                        if "xong" in text.lower():
                            has_xong_text = True
                            break
                    except:
                        continue
                
                # Nếu không tìm thấy text "xong", kiểm tra tên cửa sổ
                if not has_xong_text:
                    window_text = window.window_text() if hasattr(window, 'window_text') else ""
                    if "xong" in window_text.lower():
                        has_xong_text = True
                
                if has_xong_text:
                    # Tìm nút OK trong cửa sổ này
                    buttons = window.descendants(control_type="Button")
                    
                    for button in buttons:
                        try:
                            button_text = button.window_text() if hasattr(button, 'window_text') else ""
                            if button_text.lower() == "ok":
                                print("Tìm thấy popup 'xong' với nút OK. Đang click...")
                                button.click()
                                print("Đã click nút OK")
                                return True
                        except:
                            continue
                    
                    # Nếu không tìm thấy nút có nhãn "OK", thử tìm nút duy nhất (thường là OK)
                    if len(buttons) == 1:
                        print("Tìm thấy popup 'xong' với một nút duy nhất. Đang click...")
                        buttons[0].click()
                        print("Đã click nút")
                        return True
            except Exception as inner_e:
                print(f"Lỗi khi kiểm tra cửa sổ: {str(inner_e)}")
                continue
        
        # Thử phương pháp khác: sử dụng phím Enter để đóng dialog cơ bản
        print("Không tìm thấy popup cụ thể. Thử gửi phím Enter...")
        from pywinauto.keyboard import send_keys
        send_keys("{ENTER}")
        time.sleep(0.5)
        
        print("Không tìm thấy popup 'xong'")
        return False
        
    except Exception as e:
        print(f"Lỗi khi tìm và đóng popup 'xong': {str(e)}")
        return False
def dismiss_update_dialog(app, timeout=3):
    import time
    try:
        start_time = time.time()
        while time.time() - start_time < timeout:
            dialogs = app.windows(visible_only=True)
            for dialog in dialogs:
                title = dialog.window_text().lower()
                if "update" in title or "cập nhật" in title:
                    print(f"Đã phát hiện dialog update: {title}, đang đóng...")
                    try:
                        # Duyệt tất cả button con
                        for btn in dialog.descendants():
                            try:
                                if btn.friendly_class_name() == "Button":
                                    btn_text = btn.window_text().lower()
                                    if any(x in btn_text for x in ["no", "không", "cancel", "hủy", "đóng"]):
                                        btn.click_input()
                                        print(f"Đã bấm nút '{btn.window_text()}' để tắt dialog update.")
                                        time.sleep(0.5)
                                        return True
                            except Exception:
                                continue
                        # Nếu không có nút, thử đóng dialog
                        dialog.close()
                        print("Đã đóng dialog update bằng close().")
                        time.sleep(0.5)
                        return True
                    except Exception as e:
                        print(f"Lỗi khi đóng dialog update: {e}")
            time.sleep(0.3)
        print("Không phát hiện dialog update.")
        return True
    except Exception as e:
        print(f"Error handling update dialog: {e}")
        return False
def click_start_button(window):
    dismiss_update_dialog(app)
    print("Đang tìm và nhấn nút 'Bắt đầu'...")
    try:
        # Tìm nút "Bắt đầu" hoặc "Start"
        for btn_text in ["Bắt đầu", "Start"]:
            try:
                btn = window.child_window(title_re=f".*{btn_text}.*", control_type="Button")
                if btn.exists():
                    btn.click_input()
                    print(f"Đã nhấn nút '{btn_text}'")
                    return True
            except Exception:
                continue
        print("Không tìm thấy nút 'Bắt đầu' hoặc 'Start'.")
        return False
    except Exception as e:
        print(f"Lỗi khi nhấn nút 'Bắt đầu': {e}")
        return False


CONFIG_FILE = "config.json"

# Thêm biến để log trạng thái
log_text = None

def log(msg):
    if log_text:
        log_text.insert(tk.END, msg + "\n")
        log_text.see(tk.END)
    print(msg)

def select_folder_subprocess():
    import subprocess
    import tempfile
    
    # Create a temporary VBS script
    vbs_file = tempfile.NamedTemporaryFile(delete=False, suffix='.vbs')
    vbs_file.write(b'''
    Set objShell = CreateObject("Shell.Application")
    Set objFolder = objShell.BrowseForFolder(0, "Select Folder", 0)
    If Not objFolder Is Nothing Then
        WScript.Echo objFolder.Self.Path
    End If
    ''')
    vbs_file.close()
    
    # Run the script
    result = subprocess.run(['cscript', '//NoLogo', vbs_file.name], 
                           capture_output=True, text=True)
    
    # Delete the temporary file
    import os
    os.unlink(vbs_file.name)
    
    # Return the selected path
    if result.stdout.strip():
        return result.stdout.strip()
    return ""

def select_video_folder():
    folder = select_folder_subprocess()
    if folder:
        video_folder_var.set(folder)

def select_srt_folder():
    folder = select_folder_subprocess()
    if folder:
        srt_folder_var.set(folder)
def save_input():
    # Lưu dữ liệu textbox, hai đường dẫn và ngôn ngữ vào file config.json
    content = input_text.get("1.0", tk.END).strip()
    data = {
        "video_folder": video_folder_var.get(),
        "srt_folder": srt_folder_var.get(),
        "lines": content.splitlines(),
        "ocr_lang1": lang1_var.get(),
        "ocr_lang2": lang2_var.get()
    }
    with open(CONFIG_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)
    print("Đã lưu dữ liệu vào", CONFIG_FILE)
    messagebox.showinfo("Thông báo", "Lưu dữ liệu thành công!")

def load_config():
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
            video_folder_var.set(data.get("video_folder", ""))
            srt_folder_var.set(data.get("srt_folder", ""))
            lang1_var.set(data.get("ocr_lang1", "en"))
            lang2_var.set(data.get("ocr_lang2", "ch_sim"))
            lines = data.get("lines", [])
            input_text.delete("1.0", tk.END)
            if lines:
                input_text.insert(tk.END, "\n".join(lines))
def load_config():
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
            video_folder_var.set(data.get("video_folder", ""))
            srt_folder_var.set(data.get("srt_folder", ""))
            lines = data.get("lines", [])
            input_text.delete("1.0", tk.END)
            if lines:
                input_text.insert(tk.END, "\n".join(lines))

def start_action():
    # Lấy dữ liệu từ GUI
    key_value_lines = input_text.get("1.0", tk.END).strip().splitlines()
    key_value_pairs = {}
    for line in key_value_lines:
        if ':' in line:
            k, v = line.split(':', 1)
            key_value_pairs[k.strip()] = v.strip()
    video_folder = video_folder_var.get().replace('/', '\\')
    srt_folder = srt_folder_var.get().replace('/', '\\')
    if not key_value_pairs or not video_folder or not srt_folder:
        messagebox.showerror("Lỗi", "Vui lòng nhập đủ thông tin!")
        return

    # Chạy automation ở thread khác để không block GUI
    def run_automation():
        global app, log_text, main_window
        try:
            log("Bắt đầu tự động hóa AutoVoice...")
            app_path = r".\AutoVoice\AutoVoice\AutoVoice.exe"
            app = Application(backend="uia").connect(path=app_path)
            main_window = app.window(title_re=".*AutoVoice.*")
            main_window.wait('visible')
            with tempfile.NamedTemporaryFile("w", encoding="utf-8", delete=False) as f:
                for k, v in key_value_pairs.items():
                    # Đảm bảo đường dẫn value cũng dùng \
                    f.write(f"{k.replace('/', '\\')}:{v.replace('/', '\\')}\n")
                key_value_file = f.name

            process_videos_with_keys(main_window, key_value_file, video_folder, srt_folder)

            log("Hoàn thành tự động hóa.")
        except Exception as e:
            log(f"Lỗi: {e}")

    threading.Thread(target=run_automation, daemon=True).start()

def stop_action():
    messagebox.showinfo("Thông báo", "Chức năng dừng chưa được hỗ trợ.")

root = tk.Tk()
root.title("AutoVoice GUI")

# Video folder
video_folder_var = tk.StringVar()
tk.Label(root, text="Thư mục Video:").grid(row=0, column=0, sticky="w", padx=5, pady=5)
tk.Entry(root, textvariable=video_folder_var, width=40).grid(row=0, column=1, padx=5, pady=5)
tk.Button(root, text="Chọn...", command=select_video_folder).grid(row=0, column=2, padx=5, pady=5)

# SRT folder
srt_folder_var = tk.StringVar()
tk.Label(root, text="Thư mục SRT:").grid(row=1, column=0, sticky="w", padx=5, pady=5)
tk.Entry(root, textvariable=srt_folder_var, width=40).grid(row=1, column=1, padx=5, pady=5)
tk.Button(root, text="Chọn...", command=select_srt_folder).grid(row=1, column=2, padx=5, pady=5)
def check_languages():
    """
    Kiểm tra xem 2 ngôn ngữ đã nhập có thể sử dụng với EasyOCR và cùng nhau không
    """
    lang1 = lang1_var.get().strip()
    lang2 = lang2_var.get().strip()
    
    if not lang1:
        messagebox.showerror("Lỗi", "Vui lòng nhập ít nhất một ngôn ngữ!")
        return
    
    log(f"Đang kiểm tra ngôn ngữ: {lang1}" + (f", {lang2}" if lang2 else ""))
    
    try:
        # Kiểm tra ngôn ngữ với EasyOCR
        import easyocr
        if lang2:
            reader = easyocr.Reader([lang1, lang2])
            messagebox.showinfo("Thành công", f"Các ngôn ngữ '{lang1}' và '{lang2}' hoạt động tốt với EasyOCR!")
        else:
            reader = easyocr.Reader([lang1])
            messagebox.showinfo("Thành công", f"Ngôn ngữ '{lang1}' hoạt động tốt với EasyOCR!")
        
        # Hiển thị các mã ngôn ngữ được hỗ trợ
        supported = ", ".join(easyocr.LANGUAGES.keys())
        log(f"Các ngôn ngữ được hỗ trợ: {supported}")
        
    except Exception as e:
        messagebox.showerror("Lỗi", f"Không thể sử dụng ngôn ngữ: {e}")
        log(f"Lỗi khi kiểm tra ngôn ngữ: {e}")
# Thêm vào phần khai báo biến (trước root.mainloop())
lang1_var = tk.StringVar(value="en")  # Mặc định là tiếng Anh
lang2_var = tk.StringVar(value="ch_sim")  # Mặc định là tiếng Trung giản thể
# Thêm vào sau phần SRT folder (row 1), trước phần input_text
# EasyOCR languages
# Thêm vào sau phần SRT folder (row 1), trước phần input_text
# EasyOCR languages
tk.Label(root, text="Ngôn ngữ OCR 1:").grid(row=2, column=0, sticky="w", padx=5, pady=5)
tk.Entry(root, textvariable=lang1_var, width=10).grid(row=2, column=1, sticky="w", padx=5, pady=5)

tk.Label(root, text="Ngôn ngữ OCR 2:").grid(row=3, column=0, sticky="w", padx=5, pady=5)
tk.Entry(root, textvariable=lang2_var, width=10).grid(row=3, column=1, sticky="w", padx=5, pady=5)

tk.Button(root, text="Kiểm tra ngôn ngữ", command=check_languages).grid(row=3, column=2, padx=5, pady=5)

# Dịch các hàng khác xuống
tk.Label(root, text="Nhập nội dung:").grid(row=4, column=0, sticky="nw", padx=5, pady=5)
input_text = scrolledtext.ScrolledText(root, width=50, height=10)
input_text.grid(row=4, column=1, columnspan=2, padx=5, pady=5, sticky="w")

# Buttons
tk.Button(root, text="Lưu", width=10, command=save_input).grid(row=5, column=0, padx=5, pady=10)
tk.Button(root, text="Start", width=10, command=start_action).grid(row=5, column=1, padx=5, pady=10, sticky="w")
tk.Button(root, text="Stop", width=10, command=stop_action).grid(row=5, column=2, padx=5, pady=10, sticky="w")

# Thêm khung log trạng thái
tk.Label(root, text="Log trạng thái:").grid(row=6, column=0, sticky="nw", padx=5, pady=5)
log_text = scrolledtext.ScrolledText(root, width=50, height=10, state="normal")
log_text.grid(row=6, column=1, columnspan=2, padx=5, pady=5, sticky="w")
# Load config khi mở tool
load_config()

root.mainloop()
